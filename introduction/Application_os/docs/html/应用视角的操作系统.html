<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="css/prism.min.css"/><link rel="stylesheet" type="text/css" href="css/katex.min.css"/><link rel="stylesheet" type="text/css" href="css/wolai.css"/><title>应用视角的操作系统 - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body class="font-kai"><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="应用视角的操作系统" class="main-title"></div></div></header><article><h2 id="9GrHgUBysmyAeguCbPkYHq" class="wolai-block"><span class="inline-wrap">最小的应用程序</span></h2><h3 id="7myAQVbmfEqJTnViLNWNx1" class="wolai-block"><span class="inline-wrap">复习相关工具</span></h3><ol class="wolai-block"><li id="sx8T2Gp7PKGXuJJkpPizMC"><div class="marker"></div><span class="inline-wrap"><code>objdump -d</code></span><span class="inline-wrap">反汇编</span></li><li id="kd96LMJH9nWcnZcUyf6oUY"><div class="marker"></div><span class="inline-wrap"><code>readelf -a</code></span><span class="inline-wrap">查看所有的<span class="jill"></span>ELF<span class="jill"></span>信息</span></li><li id="4bGBBPW2tzxs3tRkm9KEXN"><div class="marker"></div><span class="inline-wrap"><code>--verbose</code></span><span class="inline-wrap">查看所有的编译选项，</span><span class="green inline-wrap"><u>可以看到在哪里找头文件</u></span><span class="inline-wrap"> </span><span class="inline-wrap"><code>gcc --verbose hello.c</code></span><code-block id="c2Th532onAHpT431kHHz2C" class="wolai-block"><div class="wolai-pre"><div data-lang="C" class="marker"></div><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"..."</span> <span class="token expression">search starts here<span class="token operator">:</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;...></span> <span class="token expression">search starts here<span class="token operator">:</span></span></span>
 <span class="token operator">/</span>usr<span class="token operator">/</span>lib<span class="token operator">/</span>gcc<span class="token operator">/</span>x86_64<span class="token operator">-</span>linux<span class="token operator">-</span>gnu<span class="token operator">/</span><span class="token number">11</span><span class="token operator">/</span>include
 <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>include
 <span class="token operator">/</span>usr<span class="token operator">/</span>include<span class="token operator">/</span>x86_64<span class="token operator">-</span>linux<span class="token operator">-</span>gnu
 <span class="token operator">/</span>usr<span class="token operator">/</span>include
End of search list<span class="token punctuation">.</span>
</pre></div></code-block></li><li id="pzz5ykSDQixNJHYzZRqp1E"><div class="marker"></div><span class="inline-wrap"><code>-WL,--verbose</code></span><span class="inline-wrap">查看所有的链接选项，</span><span class="green inline-wrap"><u>解释了<span class="jill"></span>end<span class="jill"></span>符号的由来</u></span><span class="inline-wrap"> </span><span class="inline-wrap"><code>gcc -Wl,--verbose hello.c</code></span><code-block id="fXtWz99wDAj5dWEydPQ7i6" class="wolai-block"><div class="wolai-pre"><div data-lang="6502 Assembly" class="marker"></div><pre><span class="token constant">OUTPUT_FORMAT</span><span class="token punctuation">(</span><span class="token string">"elf64-x86-64"</span><span class="token punctuation">,</span> <span class="token string">"elf64-x86-64"</span><span class="token punctuation">,</span>
        <span class="token string">"elf64-x86-64"</span><span class="token punctuation">)</span>
<span class="token constant">OUTPUT_ARCH</span><span class="token punctuation">(</span>i386<span class="token operator">:</span>x86<span class="token operator">-</span><span class="token number">64</span><span class="token punctuation">)</span>
<span class="token constant">ENTRY</span><span class="token punctuation">(</span>_start<span class="token punctuation">)</span>
_end <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">;</span> <span class="token constant">PROVIDE</span> <span class="token punctuation">(</span>end <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</pre></div></code-block></li><li id="89MCHrB4hqHqMAFhRVw2G"><div class="marker"></div><span class="inline-wrap"><code>-static</code></span><span class="inline-wrap">会静态链接<span class="jill"></span>libc<span class="jill"></span>库</span></li></ol><h3 id="nbgCAXdsKk28QVMMpi8Phy" class="wolai-block"><span class="inline-wrap">尝试构建最小的<span class="jill"></span>hello world</span></h3><ol class="wolai-block"><li id="jyvoUiK1A5342T8RfssgBM"><div class="marker"></div><span class="inline-wrap"><b>去掉#include</b></span><span class="inline-wrap">：反汇编行数与之前并没有发生变化</span><div id="h2j1pWf6L2D8anwcMq87oC" class="wolai-block wolai-text"><div><span class="inline-wrap">预处理器会将#include<span class="jill"></span>所引用的内容拷贝到所在位置</span></div></div></li><li id="5Qoo1CDwpF71kjj2kbfEJQ"><div class="marker"></div><span class="inline-wrap"><b>手动链接</b></span><span class="inline-wrap">：编译出可重定向文件，然后使用<span class="jill"></span>ld<span class="jill"></span>进行</span><span class="green inline-wrap"><b>链接，报错如下</b></span><span class="inline-wrap">：</span><code-block id="9Wedu2tXzPJFJVZdSxtY4j" class="wolai-block"><div class="wolai-pre"><div data-lang="C" class="marker"></div><pre>ld<span class="token operator">:</span> 警告<span class="token operator">:</span> 无法找到项目符号 _start<span class="token punctuation">;</span> 缺省为 <span class="token number">0000000000401000</span>
ld<span class="token operator">:</span> hello<span class="token punctuation">.</span>o<span class="token operator">:</span> in function `main'<span class="token operator">:</span>
hello<span class="token punctuation">.</span>c<span class="token operator">:</span><span class="token punctuation">(</span><span class="token punctuation">.</span>text<span class="token operator">+</span><span class="token number">0x13</span><span class="token punctuation">)</span><span class="token operator">:</span> undefined reference to `puts'
</pre></div></code-block><div id="skfet1CSGSU3vFCUtmHhah" class="wolai-block wolai-text"><div><span class="inline-wrap">因为，在<span class="jill"></span>objdump<span class="jill"></span>反汇编中，可重定向文件的<span class="jill"></span>call<span class="jill"></span>并不知道要跳转到哪里</span></div></div><div id="sAkYkRQEdbRu9hExC8mdm" class="wolai-block"><figure class="wolai-left" style="width: 705.6px; flex-direction: column"><img src="media/image.png" style="width: 100%"/></figure></div></li><li id="5khnEVLURjLjFobAmMax6A"><div class="marker"></div><span class="inline-wrap"><b>去掉<span class="jill"></span>printf，再进行手动链接</b></span><span class="inline-wrap">：链接成功但是执行失败</span><div id="6QnxRUodorueHpQdFhSPxz" class="wolai-block"><figure class="wolai-left" style="width: 100%; flex-direction: column"><img src="media/image_1.png" style="width: 100%"/></figure></div><div id="mmRHQyum5Zd7HCH6uWR6Gz" class="wolai-block wolai-text"><div><span class="inline-wrap">可以发现是</span><span class="green inline-wrap"><u>ret<span class="jill"></span>在返回时</u></span><span class="inline-wrap"></span><span class="green inline-wrap"><u>，直接返回到了<span class="jill"></span>0x1<span class="jill"></span>处，是程序无法访问的内存。然后发生了段错误</u></span></div></div><div id="aiaqLqUXG5dzZgLxHkUn9d" class="wolai-block"><figure class="wolai-left" style="width: 481.6px; flex-direction: column"><img src="media/image_2.png" style="width: 100%"/></figure></div><ol class="wolai-block"><li id="geiCm51UkaSswt8uazNoeU"><div class="marker"></div><span class="inline-wrap"><code>p</code></span><span class="inline-wrap">命令 查看寄存器信息</span></li><li id="fKh5eAyx9Rk9tAXZ5BFpJP"><div class="marker"></div><span class="inline-wrap"><code>x/x </code></span><span class="inline-wrap">地址访存</span></li></ol></li><li id="6AxrJEJjppUfPtrLjBkaGz"><div class="marker"></div><span class="inline-wrap"><b>加入<span class="jill"></span>while(1)</b></span><span class="inline-wrap">：正确执行，但是不能退出</span><div id="k6KSYnmUubHsuLx4uYxuGa" class="wolai-block wolai-text"><div><span class="green inline-wrap"><b>程序的退出是需要使用<span class="jill"></span>Sys_exit<span class="jill"></span>系统调用来进行</b></span></div></div><div id="twr7ZVbrKVLvSPxrCXNxrq" class="wolai-block wolai-text"><div><span class="green inline-wrap"><b>处理器这个状态机只会无情的按照<span class="jill"></span>pc<span class="jill"></span>执行指令，但是指令集中没有规定退出程序/关闭计算机的指令，因此程序中也没有一条退出程序的指令。退出、打印等相应工作的进行都是通过系统调用，发送给操作系统来进行</b></span><span class="inline-wrap">→</span><span class="blue inline-wrap"><b>操作系统可以任意改变程序状态</b></span></div></div><blockquote id="hgfpvPQv78peDvM94kCvE7" class="wolai-block"><span class="inline-wrap"><b>关闭计算机是怎么进行的？</b></span><div id="679AD7AP6qjDK9QZ3itfuQ" class="wolai-block"><figure class="wolai-left" style="width: 676.8px; flex-direction: column"><img src="media/image_3.png" style="width: 100%"/></figure></div></blockquote></li><li id="cjJuXQZKVYuXmVztVYYqjp"><div class="marker"></div><span class="inline-wrap">使用汇编语言编写最小的<span class="jill"></span>hello world<span class="jill"></span>程序</span><div id="8XrJCdJtGKAWyDFb8kKi9a" class="wolai-block wolai-text"><div><span class="inline-wrap">C<span class="jill"></span>语言就可以通过</span><span class="inline-wrap"><code>sys/syscall.h</code></span><span class="inline-wrap">中的</span><span class="inline-wrap"><code>syscall(long number,...)</code></span><span class="inline-wrap">函数调用系统调用</span></div></div><code-block id="bjqg77iTba1dvgrTsDixsp" class="wolai-block"><div class="wolai-pre"><div data-lang="C" class="marker"></div><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/syscall.h></span></span>

<span class="token comment">// The x86-64 system call Application Binary Interface (ABI):</span>
<span class="token comment">//     System call number: RAX</span>
<span class="token comment">//     Arguments: RDI, RSI, RDX, RCX, R8, R9</span>
<span class="token comment">//     Return value: RAX</span>
<span class="token comment">// See also: syscall(2) syscalls(2)</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">syscall3</span><span class="token expression"><span class="token punctuation">(</span>id<span class="token punctuation">,</span> a1<span class="token punctuation">,</span> a2<span class="token punctuation">,</span> a3<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
    <span class="token expression">movq $SYS_</span><span class="token punctuation">##</span><span class="token expression">id<span class="token punctuation">,</span> <span class="token operator">%</span>rax<span class="token punctuation">;</span> </span><span class="token punctuation">\</span>
    <span class="token expression">movq $a1<span class="token punctuation">,</span> <span class="token operator">%</span>rdi<span class="token punctuation">;</span> </span><span class="token punctuation">\</span>
    <span class="token expression">movq $a2<span class="token punctuation">,</span> <span class="token operator">%</span>rsi<span class="token punctuation">;</span> </span><span class="token punctuation">\</span>
    <span class="token expression">movq $a3<span class="token punctuation">,</span> <span class="token operator">%</span>rdx<span class="token punctuation">;</span> </span><span class="token punctuation">\</span>
    <span class="token expression">syscall</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">syscall2</span><span class="token expression"><span class="token punctuation">(</span>id<span class="token punctuation">,</span> a1<span class="token punctuation">,</span> a2<span class="token punctuation">)</span>  <span class="token function">syscall3</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> a1<span class="token punctuation">,</span> a2<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">syscall1</span><span class="token expression"><span class="token punctuation">(</span>id<span class="token punctuation">,</span> a1<span class="token punctuation">)</span>  <span class="token function">syscall2</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> a1<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span></span></span>

<span class="token punctuation">.</span>globl _start
_start<span class="token operator">:</span>
    <span class="token function">syscall3</span><span class="token punctuation">(</span>write<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> addr1<span class="token punctuation">,</span> addr2 <span class="token operator">-</span> addr1<span class="token punctuation">)</span> <span class="token comment">//调用sys_write系统调用　写addr1起始的(addr2-addr1)大小的数据</span>
    <span class="token function">syscall1</span><span class="token punctuation">(</span>exit<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">//调用sys_exit退出程序</span>

addr1<span class="token operator">:</span>
    <span class="token punctuation">.</span>ascii <span class="token string">"\033[01;31mHello, OS World\033[0m\n"</span> <span class="token comment">//重置（消除）所有颜色和图形，然后加粗设置红色</span>
addr2<span class="token operator">:</span>
</pre></div></code-block></li></ol><h3 id="NMfpTwfUrg1uvudnrYTmU" class="wolai-block"><span class="inline-wrap">使用<span class="jill"></span>strace<span class="jill"></span>追踪系统调用</span></h3><ol class="wolai-block"><li id="a8pEQxvGBz3GVbEbjtYQPx"><div class="marker"></div><span class="inline-wrap">操作系统上的应用程序层次</span><div id="dTFiP73ufXERfS4AX6J5JA" class="wolai-block wolai-text"><div><span class="green inline-wrap">Coreutils（Ubuntu<span class="jill"></span>使用的是<span class="jill"></span>GNU Coreutils）→系统命令<span class="jill"></span>ssh、vim、ffmpeg<span class="jill"></span>等→VScode、剪辑软件</span></div></div><ul class="wolai-block"><li id="gthyKjoVEcb4yupRC3T64L"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">BusyBox（PA<span class="jill"></span>中使用的）</span></li><li id="ve5v1DkiK2tbb4QqpVPQ2m"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Toybox</span><code-block id="8E6AYZoFKHKjuEUEcmaysq" class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre><span class="token function">wget</span> <span class="token parameter variable">-r</span> <span class="token parameter variable">-np</span> <span class="token parameter variable">-nH</span> --cut-dirs<span class="token operator">=</span><span class="token number">2</span> <span class="token parameter variable">-R</span> <span class="token string">"index.html*"</span> <span class="token string">"https://jyywiki.cn/os-demos/introduction/tar/"</span> --no-check-certificate
</pre></div></code-block><div id="5GrNtNyBiK5v6yaxJx5Puv" class="wolai-block wolai-text"><div><span class="inline-wrap">之后解压</span><span class="inline-wrap"><code>toybox-0.1.0-tar.bz2</code></span><span class="inline-wrap">，进入<span class="jill"></span>toybox-0.1.0<span class="jill"></span>内<span class="jill"></span>make<span class="jill"></span>即可</span></div></div><div id="eveKaBTzeNFBfXVoNRPEHR" class="wolai-block wolai-text"><div><span class="inline-wrap">make<span class="jill"></span>时会报错</span><span class="inline-wrap"><code>toys/mdev.c</code></span><span class="inline-wrap">内</span><span class="green inline-wrap"><u>“undefined reference to `makedev’”</u></span><span class="inline-wrap">，在</span><span class="inline-wrap"><code>toys/mdev.c</code></span><span class="inline-wrap">内添加头文件</span><span class="inline-wrap"><code>#include &lt;sys/sysmacros.h&gt;</code></span><span class="inline-wrap">重新编译即可</span></div></div></li></ul></li><li id="35dQHG2ktPPmgm5vtTtaN5"><div class="marker"></div><span class="inline-wrap">这些程序都是可执行文件，和<span class="jill"></span>minimal.S<span class="jill"></span>的可执行文件没有什么区别</span><div id="jLJRFYhtRqng8Xc4urQkpa" class="wolai-block wolai-text"><div><span class="green inline-wrap"><u>可以在<span class="jill"></span>VSCode<span class="jill"></span>中安装</u></span><span class="green inline-wrap"><u><code>Hex Editor</code></u></span><span class="green inline-wrap"><u>插件来查看并更改二进制文件</u></span></div></div></li><li id="5BbxZucUVPQMViGRb8Adcu"><div class="marker"></div><span class="inline-wrap">使用<span class="jill"></span>strace<span class="jill"></span>追踪应用程序的系统调用</span><div id="9muqVVPn9QoTP7WDb4NMYy" class="wolai-block wolai-text"><div><span class="inline-wrap"><code>strace -f 进程</code></span><span class="inline-wrap">追踪进程的系统调用，包括子进程</span></div><div id="tSFuR7QFjU1egVGS9iQVK5" class="wolai-block wolai-text"><div><span class="inline-wrap">可以管道给<span class="jill"></span>vim<span class="jill"></span>查看</span><span class="inline-wrap"><code>|&amp;</code></span><span class="inline-wrap"></span><span class="inline-wrap"><code> vim-</code></span><span class="inline-wrap">，在编辑器中使用</span><span class="inline-wrap"><code>%!grep -v -e -1</code></span><span class="inline-wrap"></span><span class="inline-wrap">去掉非法的系统调用</span></div></div></div><code-block id="d1sD61XXUYGkPs8uoKJz5v" class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre><span class="token function">wget</span> <span class="token parameter variable">-r</span> <span class="token parameter variable">-np</span> <span class="token parameter variable">-nH</span> --cut-dirs<span class="token operator">=</span><span class="token number">2</span> <span class="token parameter variable">-R</span> <span class="token string">"index.html*"</span> <span class="token string">"https://jyywiki.cn/os-demos/introduction/strace/"</span> --no-check-certificate</pre></div></code-block><div id="8JTGwTX6pWAUVEBPspavrz" class="wolai-block wolai-text"><div><span class="inline-wrap">通过</span><span class="inline-wrap"><code>make gcc-demo |&amp; vim-</code></span><span class="inline-wrap">可以看到<span class="jill"></span>gcc<span class="jill"></span>使用<span class="jill"></span>SYS_execve<span class="jill"></span>系统调用，调用了外部的<span class="jill"></span>as<span class="jill"></span>和<span class="jill"></span>ld<span class="jill"></span>来进行汇编和链接</span></div></div><div id="6SnNJ9wo4thqTccABkLoeq" class="wolai-block"><figure class="wolai-left" style="width: 100%; flex-direction: column"><img src="media/image_4.png" style="width: 100%"/></figure></div><div id="kRWhyEK1j2Aq7bc2Qj4C7u" class="wolai-block"><figure class="wolai-left" style="width: 100%; flex-direction: column"><img src="media/image_5.png" style="width: 100%"/></figure></div><div id="vs6bkgCnjRVLPioYemVevh" class="wolai-block wolai-text"><div><span class="green inline-wrap"><u>通过<span class="jill"></span>make xedit-demo<span class="jill"></span>知道了绘制也是通过系统调用进行的，write<span class="jill"></span>显示缓冲区 read<span class="jill"></span>键盘<span class="jill"></span>read<span class="jill"></span>光标</u></span></div></div></li></ol><h2 id="dcyDqa3RKmMzMBEBzBvHSk" class="wolai-block"><span class="inline-wrap">理解高级语言程序</span></h2><h3 id="6maByzDsUYN9KAMLVwd5CL" class="wolai-block"><span class="inline-wrap">Simple C<span class="jill"></span>解释器</span></h3><div id="veTxBsLMMdG7HdCG3q2FjN" class="wolai-block wolai-text"><div><span class="green inline-wrap"><u>Simple C<span class="jill"></span>的每一条语句都至多做一次运算，且条件语句中不包含运算</u></span></div></div><div id="giepgoeZqAoMP6EsxrM16s" class="wolai-block wolai-text"><div><span class="inline-wrap">可以构建状态机为：</span></div></div><div id="wkcBaZVj8WGHb97HYxTc5n" class="wolai-row"><div id="5S4CCCNAcNLvu7qsNbq6Rw" class="wolai-col" style="flex-grow: 0.5"><div id="9TZZ3pWiZLzpBatvY95MTU" class="wolai-block"><figure class="wolai-left" style="width: 626px; flex-direction: column"><img src="media/image_6.png" style="width: 100%"/></figure></div></div><div id="kXuyZVJTC7Lva2pQtKPvSn" class="wolai-col" style="flex-grow: 0.5"><ul class="wolai-block"><li id="rW4kZP6XHaLu4MpbSiAhuM"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">状态是栈帧的集合<span class="jill"></span>+<span class="jill"></span>全局变量，每一个栈帧中存储着要执行的函数，参数</span><span class="inline-wrap"><b>以及执行到的<span class="jill"></span>PC<span class="jill"></span>值</b></span><div id="cLxvQub73KajVZxHqgVGxb" class="wolai-block wolai-text"><div><span class="green inline-wrap"><u>有了<span class="jill"></span>PC，这样从函数返回时，才知道从哪继续执行</u></span></div></div></li><li id="9FV6Y6NDqSaEoAZQrDNUYv"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">初始状态：栈帧集合中只有一个栈帧，即为<span class="jill"></span>main<span class="jill"></span>的栈帧，PC<span class="jill"></span>为<span class="jill"></span>0；全局变量为初始值</span></li><li id="d3EwvQBFhQfNyWrL9fHriz"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">状态迁移</span><span class="green inline-wrap"><u>：执行栈顶栈帧的<span class="jill"></span>PC<span class="jill"></span>处语句</u></span></li></ul></div></div><div id="srLaLtuW7suVczmUySLVGB" class="wolai-block wolai-text"><div><span class="inline-wrap">下面以汉诺塔为例，构建<span class="jill"></span>Simple C<span class="jill"></span>状态机：</span></div><ul class="wolai-block"><li id="8XmKyfjwxtxbx57RW18LFY"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">不使用状态机的汉诺塔实现</span><div id="qqSBZQk7KfL9ATWYoQSsq3" class="wolai-block wolai-text"><div><span class="green inline-wrap"><u>将<span class="jill"></span>n<span class="jill"></span>个盘子从<span class="jill"></span>A<span class="jill"></span>经<span class="jill"></span>B<span class="jill"></span>移到<span class="jill"></span>C，可以先将<span class="jill"></span>n-1<span class="jill"></span>个盘子移到<span class="jill"></span>B，再把最后的一个盘子移到<span class="jill"></span>C，之后再将<span class="jill"></span>n-1<span class="jill"></span>个<span class="jill"></span>B<span class="jill"></span>上的盘子经<span class="jill"></span>A<span class="jill"></span>移到<span class="jill"></span>C</u></span></div></div><code-block id="8GsGEKeCtyJvg5PdA1HXDk" class="wolai-block"><div class="wolai-pre"><div data-lang="C" class="marker"></div><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">int</span> <span class="token function">hanoi</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">char</span> from<span class="token punctuation">,</span> <span class="token keyword">char</span> to<span class="token punctuation">,</span> <span class="token keyword">char</span> via<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c -> %c\n"</span><span class="token punctuation">,</span> from<span class="token punctuation">,</span> to<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//只有一个盘子，把它从from移到to</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> c1 <span class="token operator">=</span> <span class="token function">hanoi</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> from<span class="token punctuation">,</span> via<span class="token punctuation">,</span> to<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//先把n-1个盘子移到中间</span>
        <span class="token function">hanoi</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> from<span class="token punctuation">,</span> to<span class="token punctuation">,</span> via<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//然后把１个盘子移到to</span>
        <span class="token keyword">int</span> c2 <span class="token operator">=</span> <span class="token function">hanoi</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> via<span class="token punctuation">,</span> to<span class="token punctuation">,</span> from<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//最后再把n-1个在中间的盘子移到to</span>
        <span class="token keyword">return</span> c1 <span class="token operator">+</span> c2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></div></code-block></li><li id="hSLfzR6NT5Kc7AJvoojLkK"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">使用状态机的汉诺塔实现</span><ul class="wolai-block"><li id="cReMMqgzURPkrguPtU5akU"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">定义栈帧结构体</span><code-block id="nDL6VCuiippoprqGYwudcD" class="wolai-block"><div class="wolai-pre"><div data-lang="C" class="marker"></div><pre><span class="token keyword">struct</span> <span class="token class-name">Frame</span> <span class="token punctuation">{</span>
    <span class="token comment">// Each frame has a program counter to keep track its next</span>
    <span class="token comment">// to-be-executed statement.</span>
    <span class="token keyword">int</span> pc<span class="token punctuation">;</span>

    <span class="token comment">// The internal state of the frame. This state includes</span>
    <span class="token comment">// both arguments and local variables (if any).</span>
    <span class="token comment">//</span>
    <span class="token comment">// Arguments:</span>
    <span class="token comment">// 按照递归实现的汉诺塔，函数的参数有n from to via</span>
    <span class="token comment">// 函数内部使用的局部变量包括c1,c2</span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>
    <span class="token keyword">char</span> from<span class="token punctuation">,</span> to<span class="token punctuation">,</span> via<span class="token punctuation">;</span>

    <span class="token comment">// Local variables:</span>
    <span class="token keyword">int</span> c1<span class="token punctuation">,</span> c2<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></div></code-block></li><li id="taghAarwLBo89rjGBSgkAi"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">定义栈帧集合以及栈顶指针</span><code-block id="xskH7ZwaTHtWKtKX9xQXJS" class="wolai-block"><div class="wolai-pre"><div data-lang="C" class="marker"></div><pre>Frame stk<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//栈帧集合</span>
Frame <span class="token operator">*</span>top <span class="token operator">=</span> stk <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//top指向栈顶，没有元素时定义为栈起始-栈帧大小</span></pre></div></code-block></li><li id="3VivUcFomD2zNWcUfadkio"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">定义宏，实现函数调用和函数返回</span><code-block id="FGoB7cqipuehcENmzTcpD" class="wolai-block"><div class="wolai-pre"><div data-lang="C" class="marker"></div><pre>    <span class="token comment">// Function call: push a new frame (PC=0) onto the stack</span>
    <span class="token comment">// 调用函数，相当于新入栈一个栈帧，因为栈起始定义为stk-1</span>
    <span class="token comment">// 所以这里需要先递增栈顶指针，再入栈frame</span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">call</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">++</span>top<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span>Frame<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span>pc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span></span></span>
    
    <span class="token comment">// Function return: pop the top-most frame</span>
    <span class="token comment">// 从函数中返回相当于出栈　val中是返回值</span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">ret</span><span class="token expression"><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> top<span class="token operator">--</span><span class="token punctuation">;</span> retval <span class="token operator">=</span> <span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span></span></span>
</pre></div></code-block></li><li id="fVvCFGPHgCJp2E1mVd3VqY"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">定义函数返回值以及初始化栈</span><code-block id="qJb6UDJA4z7KpTqFJKNYqs" class="wolai-block"><div class="wolai-pre"><div data-lang="C" class="marker"></div><pre>    <span class="token comment">// The last function-return's value. It is not obvious</span>
    <span class="token comment">// that we only need one retval.</span>
    <span class="token keyword">int</span> retval <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token comment">// The initial call to the recursive function</span>
    <span class="token function">call</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> from<span class="token punctuation">,</span> to<span class="token punctuation">,</span> via<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></div></code-block></li><li id="dwuZ23xEF4aUcdrSSspAVF"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">状态更迭</span><div id="6D1t2QZWuiRE1ssQRXB6KW" class="wolai-block wolai-text"><div><span class="green inline-wrap"><u><b>每次取栈顶的栈帧<span class="jill"></span>PC</b></u></span><span class="green inline-wrap"><u>执行，根据<span class="jill"></span>PC<span class="jill"></span>所在的位置，决定它是要<span class="jill"></span>call<span class="jill"></span>还是赋值中间变量还是返回。执行完后，递增<span class="jill"></span>PC</u></span></div></div><code-block id="2gFacrfEqGR2NoyxXrjuFS" class="wolai-block"><div class="wolai-pre"><div data-lang="C" class="marker"></div><pre>   <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Fetch the top-most frame.</span>
        <span class="token comment">// 获取栈顶指针</span>
        Frame <span class="token operator">*</span>f <span class="token operator">=</span> top<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">&lt;</span> stk<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//栈空</span>
            <span class="token comment">// No top-most frame any more; we're done.</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// Jumps may change this default next pc.</span>
        <span class="token keyword">int</span> next_pc <span class="token operator">=</span> f<span class="token operator">-></span>pc <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>

        <span class="token comment">// Single step execution.</span>

        <span class="token comment">// Extract the parameters from the current frame. (It's</span>
        <span class="token comment">// generally a bad idea to reuse variable names in</span>
        <span class="token comment">// practice; but we did it here for readability.)</span>
        <span class="token comment">// 从栈帧中获得参数</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> f<span class="token operator">-></span>n<span class="token punctuation">,</span> from <span class="token operator">=</span> f<span class="token operator">-></span>from<span class="token punctuation">,</span> to <span class="token operator">=</span> f<span class="token operator">-></span>to<span class="token punctuation">,</span> via <span class="token operator">=</span> f<span class="token operator">-></span>via<span class="token punctuation">;</span>

        <span class="token comment">// 基本上是按照递归的汉诺塔函数内部实现</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span>f<span class="token operator">-></span>pc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c -> %c\n"</span><span class="token punctuation">,</span> from<span class="token punctuation">,</span> to<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token function">ret</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
               　 <span class="token punctuation">}</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span> <span class="token function">call</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> from<span class="token punctuation">,</span> via<span class="token punctuation">,</span> to<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span> f<span class="token operator">-></span>c1 <span class="token operator">=</span> retval<span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> from<span class="token punctuation">,</span> to<span class="token punctuation">,</span> via<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token number">4</span><span class="token operator">:</span> <span class="token function">call</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> via<span class="token punctuation">,</span> to<span class="token punctuation">,</span> from<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token number">5</span><span class="token operator">:</span> f<span class="token operator">-></span>c2 <span class="token operator">=</span> retval<span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token number">6</span><span class="token operator">:</span> <span class="token function">ret</span><span class="token punctuation">(</span>f<span class="token operator">-></span>c1 <span class="token operator">+</span> f<span class="token operator">-></span>c2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">default</span><span class="token operator">:</span> <span class="token function">assert</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        f<span class="token operator">-></span>pc <span class="token operator">=</span> next_pc<span class="token punctuation">;</span> <span class="token comment">//写PC</span>
    <span class="token punctuation">}</span>
</pre></div></code-block></li><li id="qjSK11wKsFkxJ2A6PRkN9t"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">最后返回最终的返回值</span><div id="aENVGWWHKWGCrFJoooTh3C" class="wolai-block wolai-text"><div><span class="inline-wrap"><code>return retval</code></span></div></div></li></ul></li></ul></div><aside id="7uTEQ6DavqRpVirgmvxdAr" class="bg-cultured wolai-block"><div data-symbol="🖍️" class="icon"></div><span class="yellow inline-wrap"><b>C/C++<span class="jill"></span>中的函数和数学中的函数的区别</b></span><div id="44o1JPSMCYb3CEyyt89F7E" class="wolai-block wolai-text"><div><span class="inline-wrap">例如，可以把<span class="jill"></span>Fibonacci 数列的递归公式写成下式，但是汉诺塔不行</span></div></div><code-block id="bLTQXpBrFPn94mYu5PCQHn" class="wolai-block"><div class="wolai-pre"><div data-lang="C++" class="marker"></div><pre><span class="token comment">// 也可以 return f(n - 2) + f(n - 1)</span>
<span class="token punctuation">;</span><span class="token keyword control-flow">return</span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></div></code-block><div id="88VDqZXAR9rf72LPpkYcVc" class="wolai-block wolai-text"><div><span class="green inline-wrap"><u>不行的根本原因在于</u></span><span class="green inline-wrap"><u><b>汉诺塔中的 printf 会带来全局的副作用，需要按照顺序输出。</b></u></span><span class="green inline-wrap"><u> C/C++ 遵循 “顺序执行” 的原则，函数的执行有 “先后” （不像数学的函数，先后是无关的），</u></span><span class="green inline-wrap"><u><b>按照不同顺序调用会导致程序输出不同的结果</b></u></span><span class="green inline-wrap"><u>。而在具体实现时，每个栈帧中存放的 “当前执行的位置” （PC） 实现了顺序执行</u></span></div></div></aside><h2 id="9iTAjx83CcKmfiewVbgx3j" class="wolai-block"><span class="inline-wrap">编译器与编译优化</span></h2><h3 id="Q6EgVnZZESXfw4pgDv9zg" class="wolai-block"><span class="inline-wrap">编译器</span></h3><div id="54ayWgXc5566YMcXJCsRYr" class="wolai-block wolai-text"><div><span class="green inline-wrap"><b>编译的过程实际上是把“C<span class="jill"></span>语言的状态机”翻译成“汇编语言的状态机”，也就是说编译器实际上是状态机之前的翻译器</b></span></div></div><div id="7e4ZCe2R8j6iB2MQBgCsVN" class="wolai-block wolai-text"><div><span class="inline-wrap">以<span class="jill"></span>Simple C<span class="jill"></span>来说，它的编译涉及到一下三个方面：</span></div><ul class="wolai-block"><li id="7nVd9Sp536D716HaSFZ2Kq"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">运算：操作数<span class="jill"></span>load<span class="jill"></span>到寄存器、然后使用对应的操作符进行运算，最后<span class="jill"></span>Store<span class="jill"></span>到内存中</span></li><li id="bMLgb7KZh1fdyYBWN4Af2a"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">分支：条件转移指令</span></li><li id="mc4qQQtoVgAag14STr3WUd"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">函数调用：使用</span><span class="inline-wrap"><code>栈帧寄存器<span class="jill"></span>stackpoint</code></span><span class="inline-wrap">，读取内存中的栈帧</span></li></ul></div><div class="block-ref"><div class="decorator"></div><div id="xbWCaKVEWLVfjRhmBusrNM" class="wolai-sub-page wolai-block"><div class="page-icon"></div><a href="https://www.wolai.com/xbWCaKVEWLVfjRhmBusrNM"><span>My_C_Compiler</span></a></div></div><blockquote id="fpnHXuzNKid3YYhwVHfpZW" class="wolai-block"><span class="green inline-wrap"><u>由于<span class="jill"></span>Simple C<span class="jill"></span>这种直接翻译的性质，将<span class="jill"></span>C<span class="jill"></span>语言又称之为“高级汇编语言”——存在<span class="jill"></span>C<span class="jill"></span>代码到指令集的直接对应关系，状态机和迁移都可以“直译”</u></span></blockquote><h3 id="wv3XcPya676qu9vY6EGSPj" class="wolai-block"><span class="inline-wrap">编译优化</span></h3><div id="kQDQSYpqNn4H1mVM1qxDyx" class="wolai-block wolai-text"><div><span class="inline-wrap">C 语言编译器在进行代码优化时，</span><span class="green inline-wrap"><b>遵循的基本准则是在不改变程序的语义（即程序的行为和输出结果）的前提下，提高程序的执行效率和/或减少程序的资源消耗</b></span><span class="inline-wrap"></span><span class="inline-wrap">。其中，最重要的“三板斧”是：</span></div><ul class="wolai-block"><li id="perHMcgSekwM3Fig3eQrwH"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="blue inline-wrap"><b>函数内联：将函数调用替换为函数体本身的内容</b></span></li><li id="weUNED8wT8AXLk2H39KCYV"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="blue inline-wrap"><b>常量传播：在编译时计算常量表达式的值并替换</b></span></li><li id="5ZaKPw61XoqfL6NiNKasKU"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="blue inline-wrap"><b>死代码消除：删除永远不会被执行到的代码</b></span></li></ul></div><div id="k3LHcRSiZBK7SKNTmPAkCN" class="wolai-block wolai-text"><div><span class="inline-wrap">而编译器一般不优化的部分包括：</span></div><ul class="wolai-block"><li id="ii3YqATpiQpv3RBMV1ukPh"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="blue inline-wrap"><b>本执行文件内的系统调用</b></span></li><li id="fhLHFep3hBBe3hLkX1pcKz"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="blue inline-wrap"><b>外部函数调用（未知代码，可能内部存在系统调用）</b></span></li><li id="91AYNPVL4VW3x34LYfvnVP"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="blue inline-wrap"><b>编译器提供的不可优化标注：volatile、有函数间隔的<span class="jill"></span>load、store<span class="jill"></span>以及<span class="jill"></span>inline assembly</b></span></li></ul></div><blockquote id="vD8KhkRpneS7dyTSMxB2J2" class="wolai-block"><span class="yellow inline-wrap"><b>但是这样的编译器优化原则是有点保守的</b></span><div id="6mZFNL9up3mwmbAt5M8g4t" class="wolai-block wolai-text"><div><span class="inline-wrap">例如，下面的代码，编译器不好将其合并为一个<span class="jill"></span>printf，通过<span class="jill"></span>write<span class="jill"></span>系统调用写全部字符</span></div></div><code-block id="sTkbrUHbDcLYHVXqeEAcBY" class="wolai-block"><div class="wolai-pre"><div data-lang="C" class="marker"></div><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">26</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">putchar</span><span class="token punctuation">(</span><span class="token char">'A'</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></pre></div></code-block><div id="45LoMfUnKu6oZKxd5fj78Z" class="wolai-block wolai-text"><div><span class="blue inline-wrap"><b>因此，在现在的操作系统中存在着一种新的方向：将状态机的一部分直接放在操作系统中运行</b></span></div></div><ol class="wolai-block"><li id="ppVSaFMNsZoe8JBxqPUKCw" class="green"><div class="marker"></div><span class="inline-wrap">把代码放进操作系统中执行：XRP</span></li><li id="9rSW8WWECF98nBJMCbTLBz" class="green"><div class="marker"></div><span class="inline-wrap">单个应用就是一个操作系统：Unikernel</span></li></ol></blockquote><div id="x2R9GjrC4GJWvxVzGuzdCX" class="wolai-block wolai-text"><div></div></div></article><footer></footer></body></html>